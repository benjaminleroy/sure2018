---
title: "Imputation - Imani"
author: "Imani C."
date: "July 1, 2018"
output: html_document
---
View(country)
```{r}
library(mice)
#seperates indv from other data
merge_imp <-big_merge[27:80]
#turns everything to a factor
merge_imp<-as.data.frame(lapply(merge_imp,factor))

#groups variables together
controlgroup <-names(merge_imp)[6:23]

labourgroup<-names(merge_imp)[31:43]

relationgroup <- names(merge_imp)[50:54]


ind_imp<- mice(merge_imp, maxit=0, blocks=list(c(controlgroup),c(labourgroup),c(relationgroup)))

mat1<- ind_imp$predictorMatrix

#takesout Sex/Labor varaible
mat1[,24:27]<-0


ind_imp2 <-mice(merge_imp, predictorMatrix = mat1, method="logreg", blocks = list(c(controlgroup),c(labourgroup),c(relationgroup)))

ind_imp2
```



#work based on the email


2, Isolating columsn wtih only 1 factor levels
```{r}
merge_imp <-big_merge[c(2,13,27:80)]
#turns everything to a factor
merge_imp<-as.data.frame(lapply(merge_imp,factor))



merge_imp2 <- merge_imp[, sapply(merge_imp, function(col)  length(levels(col))) < 2] #meansOfControlFalsePRomises is the onyl column with NA'a and 1



```


3. Labor, Recruiter, and means of control (I do not think that the other categories can use this type of logic in terms of filling in NA's)

4.What are the two options?????? 
5. 
General blocks should be the same as seen above in my mice blockss

6.

```{r}


# x is the x columns (to regress on)
# y is the y vector 
# ry is the a logic vector (length y) with TRUE for logic for **Non-NA** y values
#
# YOUR JOB: interpret the funtion, make comments on what it's doing/ 
# make side comments for each step and a summarization of the function at the end
# in a few sentences.
remove.lindep <- function(x, y, ry, eps = 1e-04, maxcor = 0.99, 
                          allow.na = TRUE, frame = 4, ...) {
  # returns a logical vector of length ncol(x)
  
  
  
  if (ncol(x) == 0)  
    return(NULL)
  if (eps <= 0)
    stop("\n Argument 'eps' must be positive.") 
  
  # Keep all predictors if we allow imputation of fully missing y
  if (allow.na && sum(ry) == 0) return(rep.int(TRUE, ncol(x)))
  
  xobs <- x[ry, , drop = FALSE]
  yobs <- as.numeric(y[ry])
  if (var(yobs) < eps) return(rep(FALSE, ncol(xobs)))
  
  keep <- unlist(apply(xobs, 2, var) > eps)
  keep[is.na(keep)] <- FALSE
  highcor <- suppressWarnings(unlist(apply(xobs, 2, cor, yobs) < maxcor))
  keep <- keep & highcor
  if (all(!keep))
    updateLog(out = "All predictors are constant or have too high correlation.", 
              frame = frame)
  
  # no need to calculate correlations, so return
  k <- sum(keep)
  if (k <= 1L) return(keep)  # at most one TRUE
  
  # correlation between x's
  cx <- cor(xobs[, keep, drop = FALSE], use = "all.obs")
  eig <- eigen(cx, symmetric = TRUE)
  ncx <- cx
  while (eig$values[k]/eig$values[1] < eps) {
    j <- seq_len(k)[order(abs(eig$vectors[, k]), decreasing = TRUE)[1]]
    keep[keep][j] <- FALSE
    ncx <- cx[keep[keep], keep[keep], drop = FALSE]
    k <- k - 1
    eig <- eigen(ncx)
  }
  if (!all(keep)) {
    out <- paste(dimnames(x)[[2]][!keep], collapse = ", ")
    updateLog(out = out, frame = frame)
  }
  return(keep)

}
```


The point of this function is to make columns linearly indepepndednt. I assume 
we are using this to help us finish imputing using mice as that is one of main problems. 
Not 100 percent sure how this function works to be completely honest. 


